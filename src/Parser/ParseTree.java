/** Concrete Parse Tree
 * 
 * Generated by parser, to be transformed into AST.
 * */

package Parser;

import Scanner.Token;

public interface ParseTree {
    ParseTree[] getChildren();
    void setChildren(ParseTree... newChildren);
    void visit(Visitor v) throws ParseException;
    public String getRuleString();
    public String getSymbol();
    public boolean isTerminal();
    public Token getToken();
    public interface Visitor {
    	void visit(Token t) throws ParseException; // Terminal node
        void visit(String lhs, ParseTree... children) throws ParseException; // Non-Terminal
    }
}

abstract class AParseTree implements ParseTree {
    ParseTree[] children;
    public ParseTree[] getChildren() { return children; }
    public void setChildren(ParseTree... newChildren) { children = newChildren; }
    protected AParseTree(ParseTree... children) { this.children = children; }
    
    public String getRuleString() {
    	String s = getSymbol();
    	for (ParseTree child : children) {
    		s += " " + child.getSymbol();
    	}
    	return s;
    }
}

class Terminal extends AParseTree {
    public final Token token;
    public Terminal(Token t) {
    	token = t;
    	}
    @Override public void visit(Visitor v) throws ParseException {
        v.visit(token);
    }
    public String getSymbol() {
        return token.getCfgName();
    }
    
    public boolean isTerminal(){
    	return true;
    }
    
    public Token getToken(){
    	return token;
    }
}

class NonTerminal extends AParseTree {
    public final String lhs;
    public NonTerminal(String lhs, ParseTree... children) {
        super(children);
        this.lhs = lhs;
    }
    @Override public void visit(Visitor v) throws ParseException {
        v.visit(lhs, children);
    }
    public String getSymbol() {
        return lhs;
    }
    
    public boolean isTerminal(){
    	return false;
    }
    
    public Token getToken(){
    	return null;
    }
}
